<!DOCTYPE html>
<html lang="ru">
<head>
  <title>Электронное учебное пособие Соадминистрирование баз данных и серверов</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="css/style.css">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>


  <header class="header">
    <div class="container">
      <div class="header__inner">
        <div class="header__logo">
         <img src="images/logotype-active.png" width="100px" alt="">
         <div class="name">
           <h2>Электронное учебное пособие</h2>
           <h2>Соадминистрирование баз данных и серверов</h2>
         </div>
         <a id="top"></a>
        </div>
        <nav class="nav">
          <a class="nav__link" href="index.html">Учебник</a>
          <a class="nav__link" href="basepr.html">Практика</a>
            <a class="nav__link" href="video1.html">Видеоматериал</a>
        </nav>
      </div>
    </div>
  </header>
<div class="layout">
  <aside class="aside-menu">
    <div class="block" id="block-htmlbook-block-28"><div class="block-content"></div></div>
    <div class="block" id="block-htmlbook-book-navigation">
       <h2 class="block-title">Содержание</h2>
     <div class="block-content">
  <ul class="menu">
                 <li class="leaf-collapsed">

                 <a class="not-active" href="index.html">Раздел 1. Технологии администрирования серверов и баз данных</a>
                    </li>
                    <li class="leaf-collapsed">

                 <a class="not-active">Тема 1.1. Принципы построения и администрирования баз данных
                        </a>
                       </li>
                         <div class="sub-menu">
                           <li class="leaf-collapsed">

                        <a class="not-active" href="book111.html">1.Обязанности администратора баз данных. Основные утилиты администратора баз данных. Режимы запуска и останова базы данных.</a>
                              </li>

     	      <li class="leaf-collapsed">

         <a class="not-active" href="book112.html">2.Пользователи базы данных. Привилегии, назначение привилегий. Управление пользователями баз данных</a>
               </li>
               <li class="leaf-collapsed">

         <a class="not-active" href="book113.html">3.Табличные пространства и файлы данных. Модели и типы данных.</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book114.html">4.Схемы и объекты схемы данных. Блоки данных, экстенты сегменты.</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book115.html">5.Структуры памяти. Однопроцессорные и многопроцессорные базы данных</a>
               </li>
               <li class="leaf_active-trail">
        <a href="book116.html" class="is-active">6.Транзакции, блокировки и согласованность данных
               <span class="pointer" style="border-width: 11px 6px;"></span></a>
              </li>

     	      <li class="leaf-collapsed">

         <a class="not-active" href="book117.html">7.Журнал базы данных: структура и назначение файлов журнала, управление переключениями и контрольными точками</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book118.html">8. Словарь данных: назначение, структура, префиксы </a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book119.html">9. Правила Дейта</a>
               </li>
             </div>

     	      <li class="leaf-collapsed">

         <a class="not-active">Тема 1.2. Серверы баз данных</a>
               </li>

               <div class="sub-menu">

     	      <li class="leaf-collapsed">


         <a class="not-active" href="book121.html">1.Понятие сервера. Классификация серверов. Принципы разделения между клиентскими и серверными частями. Типовое разделение функций</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book122.html">2.Протоколы удаленного вызова процедур. Требования к аппаратным возможностям и базовому программному обеспечению клиентов и серверов</a>
               </li>
     	      <li class="leaf-collapsed">
         <a class="not-active" href="book123.html">3.Хранимые процедуры и триггеры</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book124.html">4.Характеристики серверов баз данных. Механизмы доступа к базам данных</a>
               </li>
               <li class="leaf-collapsed">
              <a class="not-active" href="book125.html">5. Аппаратное обеспечение. Для квалификации «Администратор баз данных»: Развертывание серверов баз данных</a>
                  </li>
                  <li class="leaf-collapsed">
                 <a class="not-active" href="book126.html">6. Банк данных: состав, схема</a>
                     </li>
             </div>
             <li class="leaf-collapsed">
          <a class="not-active">Тема 1.3.Администрирование баз данных и серверов</a>
                </li>
     <div class="sub-menu">
      <li class="leaf-collapsed">
      <a class="not-active" href="book131.html">1.Технология установки и настройка сервера MySQL в операционной системе Windows.Клиентские настройки, протоколирование, безопасность</a>
         </li>
         <li class="leaf-collapsed">
      <a class="not-active" href="book132.html">2.Технология установки и настройка сервера MySQL в операционных системах Linux</a>
            </li>
            <li class="leaf-collapsed">
         <a class="not-active" href="book133.html">3.Удаленное администрирование</a>
               </li>
               <li class="leaf-collapsed">
            <a class="not-active" href="book134.html">4.Аудит базы данных. Аудиторский журнал. Установка опций, включение и отключение аудита. Очистка и уменьшение размеров журнала</a>
                  </li>
                  <li class="leaf-collapsed">
               <a class="not-active" href="book135.html">5.Технологии создания базы данных с применением языка SQL.Добавление, удаление данных и таблиц</a>
                     </li>
                     <li class="leaf-collapsed">
                  <a class="not-active" href="book136.html">6.Создание запросов, процедур и триггеров. Для квалификации «Администратор баз данных». Создание запросов и процедур на изменение структуры базы данных</a>
                        </li>
                        <li class="leaf-collapsed">
                     <a class="not-active" href="book137.html">7.Динамический SQL и его операторы.</a>
                           </li>
                           <li class="leaf-collapsed">
                        <a class="not-active" href="book138.html">8.Особенности обработки данных в объектно-ориентированных базах данных</a>
                              </li>
                              <li class="leaf-collapsed">
                           <a class="not-active" href="book139.html">9. Инструменты мониторинга нагрузки сервера</a>
                                 </li>

    </div>
    <li class="leaf-collapsed">
    <a class="not-active" href="index.html">Раздел 2. Обеспечение качества и сертификация информационных систем </a>
       </li>
       <li class="leaf-collapsed">
     <a class="not-active">Тема 2.1. Защитаи сохранность информации баз данных</a>
          </li>
     <div class="sub-menu">
          <li class="leaf-collapsed">
        <a class="not-active" href="book211.html">1.Законодательство Российской Федерации в области защиты информации. Требования безопасности к серверам баз данных. Классы защиты</a>
             </li>
             <li class="leaf-collapsed">
           <a class="not-active" href="book212.html">2.Основные группы методов противодействия угрозам безопасности в корпоративных сетях</a>
                </li>
                <li class="leaf-collapsed">
             <a class="not-active" href="book213.html">3.Программно-аппаратные методы защиты процесса обработки и передачи информации. Политика безопасности, настройка политики безопасности</a>
                   </li>
                   <li class="leaf-collapsed">
                <a class="not-active" href="book214.html">4.Виды неисправностей систем хранения данных</a>
                      </li>
                      <li class="leaf-collapsed">
                   <a class="not-active" href="book215.html">5.Резервное копирование: цели, методы, концепции, планирование, роль журнала транзакций. Виды резервных копий</a>
                         </li>
                         <li class="leaf-collapsed">
                      <a class="not-active" href="book216.html">6.Утилиты резервного копирования </a>
                            </li>
                            <li class="leaf-collapsed">
                         <a class="not-active" href="book217.html">7.Восстановление базы данных: основные алгоритмы и этапы</a>
                               </li>
                               <li class="leaf-collapsed">
                            <a class="not-active" href="book218.html">8.Восстановление носителей. Воссоздание утраченных файлов. Полное восстановление. Неполное восстановление</a>
                                  </li>
                                  <li class="leaf-collapsed">
                               <a class="not-active" href="book219.html">9.Мониторинг активности и блокирование</a>
                                     </li>
                                     <li class="leaf-collapsed">
                                  <a class="not-active" href="book2110.html">10.Автоматизированные средства аудита</a>
                                        </li>
                                        <li class="leaf-collapsed">
                                     <a class="not-active" href="book2111.html">11.Брандмауэры</a>
                                           </li>
                                  </div>
     <li class="leaf-collapsed">
      <a class="not-active">Тема 2.2 Сертификация информационных систем</a>
        </li>
        <div class="sub-menu">
        <li class="leaf-collapsed">
         <a class="not-active" href="book221.html">1.Уровни качества программной продукции</a>
           </li>
           <li class="leaf-collapsed">
            <a class="not-active" href="book222.html">2.Требования к конфигурации серверного оборудования и локальных сетей.Оформление требований.</a>
              </li>
              <li class="leaf-collapsed">
               <a class="not-active" href="book223.html">3.Объекты информатизации, требующие обязательной сертификации программных средств и обеспечения</a>
                 </li>
                 <li class="leaf-collapsed">
                  <a class="not-active" href="book224.html">4.Сертификаты безопасности: виды, функции, срок действия. Проверка наличия сертификата безопасности</a>
                    </li>
                    <li class="leaf-collapsed">
                     <a class="not-active" href="book225.html">5. Системы сертификации. Процедура сертификации.</a>
                       </li>
                       <li class="leaf-collapsed">
                        <a class="not-active" href="book226.html">6. Платформы и центры сертификации. Сертификат разработчика. Процесс подписи и проверки кода</a>
                          </li>
                          <li class="leaf-collapsed">
                           <a class="not-active" href="book227.html">7. SSL сертификат: содержание, формирование запроса, проверка данных с помощью сервисов</a>
                             </li>
                             <li class="leaf-collapsed">
                              <a class="not-active" href="spicok.html">Список источников</a>
                                </li>
                              </div>
                                                       </ul>



     </div>
    </div>
 </aside>

 <div id="content" class="three-col">
   <div class="block" id="block-content">
     <div class="block-content">
       <article role="article">
         <h1 class="h1-content"><span>6.Транзакции, блокировки и согласованность данных</span></h1>
         <nav role="navigation" aria-labelledby="book-label-2" class="book-navigation">
           <div class="page-links"><a href="book115.html" rel="prev" class="page-previous" title="Прошлая Тема">
             <i class="arrow icon-prev"><img src="images/arrowleft.png" alt=""></i>Тема 1.5</a>
             <a href="index.html" class="page-up" title="Содержание"><i class="arrow icon-up">
             <img src="images/arrowup.png" alt=""></i>Содержание</a>
             <a href="book117.html" rel="next" class="page-next" title="Следующая тема">Тема 1.7.
               <i class="arrow icon-next"><img src="images/arrowright.png" alt=""></i>
             </a>
           </div>
         </nav>
           <div>

<h1>ТРАНЗАКЦИИ И БЛОКИРОВКИ</h1>

<h2>Понятие транзакции</h2>
<p class="img-content"><img src="images/book1161.png" alt="Рис. 1.1" width="608" height="296"></p>
<p class="imgsign">Рис.6.1 Понятие транзакции</p>

<p>При работе с базами данных не исключены ошибки и сбои. Они могут быть вызваны ошибками пользователей, взаимодействующих с СУБД, или неустойчивой работой компьютеров. Поэтому в СУБД применяют специальные способы отмены действий, вызвавших такие ошибки. Команда SQL, оказывающая действие на содержание и структуру БД, не является  необратимой. Пользователь может установить, что произойдет после окончания ее действий: останутся ли внесенные изменения БД или они будут проигнорированы. Для этого последовательность операций над базой данных объединяют в группы - транзакции.
</p><p>
Транзакцией называется последовательность операций, производимых над базой данных и переводящих ее из одного непротиворечивого состояния в другое непротиворечивое состояние.
</p><p>
Транзакция рассматривается как некоторое неделимое действие над БД, осмысленное с точки зрения пользователя, то есть это логическая единица работы системы. Транзакция начинается всякий раз, когда происходит сеанс работы с базой данных.
</p><p>
Примером транзакции может быть перевод денег через банкомат. Сумма 100 т.р. переводится с текущего счета на карт-счет. Программа вычитает сумму с текущего счета, после чего прибавляет ее к карт-счету. Во время работы программы после выполнения первой модификации происходит сбой питания, и увеличения карт-счета не происходит. Для того чтобы избежать подобной ситуации обе команды должны быть объединены в транзакцию. В  случае, когда все команды транзакции не выполняются, происходит откат транзакции.
</p><p>
Определим транзакцию по вводу данных о вновь поступивших в библиотеку книгах. Эту операцию можно разбить на 2 последовательные: сначала ввод данных о книге – это новая строка в таблице Книги. Затем необходимо ввести данные обо всех экземплярах книги  - это ввод набора новых строк в таблицу Экземпляры. Если эта последовательность действий будет прервана, то база данных не будет соответствовать реальному объекту, поэтому желательно выполнять ее как единую работу над базой данных.</p>

<h2>Свойства транзакций. Способы завершения транзакций</h2>
<p>Существуют различные модели транзакций, которые могут быть классифицированы на основе различных свойств, включающих структуру транзакции, параллельность внутри транзакции, продолжительность и т.д.
</p><p>
В настоящее время выделяют следующие типы транзакций: плоские или классические транзакции, цепочечные транзакции и вложенные транзакции.
       </p><p>
Плоские транзакции характеризуются классическими свойствами: атомарности, согласованности, изолированности и долговечности.</p>
<ul>
  <li>
    Свойство атомарности выражается в том, что транзакция должна быть выполнена в целом или не выполнена вовсе.
   </li><li>
   Свойство согласованности гарантирует, что по  мере выполнения транзакции данные переходят из одного согласованного состояния в другое согласованное состояние  - транзакция не разрушает взаимной согласованности данных.
   </li><li>
           Свойство изолированности означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит так, как будто они выполняются параллельно.
   </li><li>
           Свойство долговечности означают, что если транзакция завершена успешно, то те изменения данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах, даже в случае последующих ошибок.
   </li><li>
   Возможны 2 варианта завершения транзакции:
   </li><li>
           если все операторы выполнены успешно и в процессе транзакции не произошло никаких сбоев программного или аппаратного обеспечения, транзакция фиксируется. (Фиксация – это запись на диск изменений в БД, которые были сделаны в процессе выполнения транзакции). До тех пор, пока транзакция не зафиксирована, эти изменения могут быть аннулированы и база данных может быть возвращена в то состояние, в котором она была на момент начала транзакции. Фиксация транзакции означает, что все результаты выполнения транзакции становятся постоянными.  Они станут видимы другим транзакциям только после того, как текущая транзакция будет зафиксирована.
   </li><li>
           Если в процессе выполнения транзакции произошел сбой, БД должна быть возвращена в исходное состояние. Откат транзакции – это действие, обеспечивающее аннулирование всех изменений данных, которые были сделаны операторами SQL в теле текущей незавершенной транзакции.
  </li>
</ul>

<h2>Операторы Transact SQL для работы с транзакциями</h2>
<p>В стандарте ANSI/ISO  определены  операторы  СOMMIT и  ROLLBACK, в стандарте начало транзакции неявно задается первым оператором модификации данных; Оператор COMMIT означает успешное завершение транзакции, результаты транзакции фиксируются во внешней памяти; при завершении транзакции оператором ROLLBACK результаты транзакции отменяются. Успешное завершение программы, в которой была инициирована транзакция, означает успешное завершение транзакции (как если бы был использован оператор COMMIT), неуспешное завершение – прерывает транзакцию (как будто был использован оператор ROLLBACK).  В этой модели каждый оператор, изменяющий состояние данных, рассматривается как транзакция. Такая  модель была реализована в первых  версиях коммерческих СУБД. В дальнейшем в СУБД  SYBASE была реализована расширенная модель транзакций.
</p><p>
В расширенной модели транзакций (например, в СУБД  SQL SERVER) предусмотрен ряд дополнительных операций:
</p><p>
·        оператор BEGIN TRANSACTION сообщает о начале транзакции;
</p><p>
·         оператор COMMIT TRANSACTION  сообщает об успешном завершении транзакции. Этот оператор, также как и COMMIT в модели стандарта  ANSI/ISO, фиксирует все изменения, которые производились в БД в процессе выполнения транзакции;
</p><p>
·         оператор SAVE TRANSACTION создает внутри транзакции точку сохранения, которая соответствует промежуточному состоянию БД, сохраненному на момент выполнения этого оператора. В операторе SAVE TRANSACTION может стоять имя точки сохранения, поэтому в ходе выполнения транзакции может быть запомнено несколько точек сохранения соответствующих нескольким промежуточным состояниям;
</p><p>
·        оператор ROLLBACK имеет 2 модификации. Если он используется без дополнительного параметра, то  он интерпретируется как оператор отката всей транзакции, если же он имеет параметр ROLLBACK n, то он интерпретируется как оператор частичного отката транзакции в точку сохранения n.
</p><p>
Точки сохранения целесообразно использовать в длинных и сложных транзакциях, чтобы обеспечить возможность отмены изменений, выполненных определенными операторами.
</p><p>
 В большинстве случаев можно установить параметр, называемый AUTOCOMMIT, который будет автоматически запоминать все выполняемые команды, причем действия, которые привели к ошибке, всегда будут автоматически отменены. Обычно этот режим устанавливается с помощью команды типа:
</p><p>
SET AUTOCOMMIT ON;
</p><p>
а возврат к обычной диалоговой обработке запросов:
</p><p>
SET AUTOCOMMIT OFF;
</p><p>
Кроме того, имеется возможность установки AUTOCOMMIT, которую СУБД выполнит автоматически при регистрации, Если сеанс пользователя завершился аварийно, – например, произошел сбой системы, то текущая транзакция выполнит автоматический откат изменений. Не рекомендуется организовывать работу так, чтобы одиночные транзакции содержали много команд, тем более не связанных между собой. Это может привести к тому, что при отмене изменений будет выполнено слишком много действий, в том числе и тех, которые являются нужными и ошибки не вызвали. Лучший вариант, когда транзакция состоит из одной команды или нескольких  тесно связанных команд.
</p><p>
Триггер выполняется как неявно определенная транзакция, поэтому внутри триггера допускается применение команд управления транзакциями. В частности, при обнаружении нарушения ограничений целостности для прерывания выполнения триггера и отмены всех изменений, которые пытался выполнить пользователь, необходимо использовать команду ROLLBACK TRANSACTION. В случае успешного завершения триггера можно использовать команду COMMIT TRANSACTION.
Выполнение команды ROLLBACK TRANSACTION или COMMIT TRANSACTION не прерывает работу триггера, поэтому следует внимательно отслеживать попытки многократного отката транзакции при выполнении разных условий.
</p><p>
Пример транзакции:
</p><p>
 BEGIN  TRAN
</p><p>
UPDATE account
</p><p>
SET balance= balance- 100
</p><p>
WHERE account_number=@s_account
</p><p>
If @@ error=0
</p><p>
BEGIN
</p><p>
  ROLLBACK TRAN
</p><p>
  RETURN
</p><p>
END
</p><p>
UPDATE card_account
</p><p>
SET balance=balance+100
</p><p>
WHERE account_number=@s_account
</p><p>
If @@ error=0
</p><p>
BEGIN
</p><p>
  ROLLBACK TRAN
</p><p>
  RETURN
</p><p>
END
</p><p>
COMMIT TRAN
</p><p>
Команда  BEGIN  TRAN сообщает серверу о начале транзакции. Это значит, что до получения сервером команды COMMIT TRAN все изменения являются временными. Следовательно, если на сервере произойдет сбой после первого обновления, произойдет откат транзакции. Никакой процесс не сможет получить доступ к данным до тех пор, пока  не будет завершена транзакция.</p>

<h2>Журнал транзакций</h2>
<p class="img-content"><img src="images/book1162.png" alt="Рис. 1.1" width="608" height="296"></p>
<p class="imgsign">Рис.6.2 Пример Журнала транзакций</p>

<p>Реализация принципа сохранения промежуточных состояний, подтверждения или отката транзакции обеспечивается специальным механизмом, для поддержки которого создана  системная структура, называемая журналом транзакций. Журнал транзакций содержит последовательность записей об изменении БД. Он предназначен для обеспечения надежного хранения данных в БД. Это предполагает возможность восстановления согласованного состояния БД после любого рода аппаратных и программных сбоев. Общие принципы журнализации и восстановления:
</p><p>
·        результаты зафиксированных транзакций должны быть сохранены в восстановленном состоянии БД;
</p><p>
·        результаты незафиксированных транзакций не должны присутствовать в восстановленном состоянии БД.
</p><p>
Это означает, что восстанавливается последнее по времени согласованное состояние БД.
</p><p>
Возможны следующие ситуации, при которых требуется производить восстановление состояния БД:
</p><p>
·        Восстановление после внезапной потери содержимого оперативной памяти (мягкий сбой). Такая ситуация может возникнуть в следующих случаях: при аварийном выключении электропитания или при  возникновении неустранимого сбоя процессора. Ситуация характеризуется потерей той части базы данных, которая  находилась  к моменту сбоя в буферах оперативной памяти.
</p><p>
·        Восстановление после поломки основного внешнего носителя БД (жесткий сбой).
</p><p>
Система должна обеспечивать восстановление как после небольших нарушений (например, после неудачно завершенных транзакций), так и после серьезных сбоев, (например сбоев питания, жестких сбоев).
</p><p>
При мягком сбое необходимо восстановить содержимое БД по содержимому журналов транзакций, хранящихся на дисках.  При жестком сбое необходимо восстановить содержимое БД по архивным копиям и журналам транзакций, которые хранятся на неповрежденных внешних носителях.
</p><p>
 Возможны два основных варианта ведения журнальной информации. В 1-м варианте для каждой транзакции поддерживается отдельный локальный журнал изменений БД этой транзакцией. Такие журналы называют локальными журналами. Они используются для локальных откатов транзакций. Кроме того, поддерживается общий журнал изменений БД, используемый для восстановления БД после мягких и жестких сбоев.
</p><p>
Этот подход позволяет быстро выполнять индивидуальные откаты транзакций, но приводит к дублированию информации в локальных и общем журналах. Поэтому чаще используют второй вариант – поддержание только общего журнала изменений БД, который используется и при выполнении индивидуальных откатов.
</p><p>
Общая структура журнала может быть представлена в  виде некоторого последовательного файла, в котором фиксируется каждое изменение БД, происходящее в ходе выполнения транзакции. Все транзакции имеют внутренние номера, поэтому в журнале транзакций фиксируются все изменения, проводимые всеми транзакциями.
</p><p>
Каждая запись в журнале помечается номером транзакции, к которой она относится, и значениями атрибутов, которые она меняет, кроме того, для каждой транзакции в журнале фиксируется команда начала и завершения транзакции.
</p><p>
Для большей надежности журнал транзакций часто дублируется системными средствами СУБД, именно поэтому объем внешней памяти во много раз превышает реальный объем данных в базе.
</p><p>
Имеется 2 варианта ведения журнала транзакций: протокол с отложенными обновлениями и протокол с немедленными обновлениями.
</p><p>
Ведение журнала по принципу отложенных обновлений предполагает следующий механизм выполнения транзакций:
</p><p>

</p><p>
1.     Когда транзакция Т1 начинается, в протокол заносится запись
</p><p>
Т1 Begin Transaction
</p><p>
2.     На     протяжении выполнения транзакции в протоколе для каждой изменяемой записи записывается новое значение
</p><p>
 Т1.ID_RECORD, атрибут, новое значение
</p><p>
 (ID_RECORD – уникальный номер записи)
</p><p>
3.     Если все действия, из которых состоит транзакция, успешно выполнены, то транзакции частично фиксируется и в протокол заносится:
</p><p>
 T1 COMMT
</p><p>
4.     После того, как транзакция зафиксирована, записи протокола, относящиеся к Т1, используются для внесения изменений в БД.

5.     Если происходит сбой, то СУБД просматривает протокол и выясняет, какие транзакции необходимо переделать. Транзакцию Т1 необходимо переделать, если протокол содержит обе записи Т1 Begin Transaction и T1 COMMT. БД может находиться в несогласованном состоянии, однако все новые значения измененных элементов данных содержатся в протоколе, и это требует повторного выполнения транзакции. Для этого используется системная процедура REDO(), которая заменяет все значения элементов данных на новые, просматривая протокол в прямом порядке.

6.     Если в протоколе не содержится команда фиксации транзакции СOMMIT, то никаких действий проводить не требуется, а транзакция запускается заново.
</p><p>


Альтернативный механизм с немедленным выполнением предусматривает внесение изменений сразу в БД, а в протокол заносятся не только новые, но и все старые значения изменяемых атрибутов, поэтому каждая запись выглядит так:
</p><p>


Т1.ID_RECORD, атрибут, новое значение старое значение
</p><p>
При этом запись в журнал предшествует непосредственному выполнению операции над БД. Когда транзакция фиксируется, то есть встречается команда T1 COMMIT, и она выполняется, то все изменения оказываются уже внесенными в БД и не требуется никаких дальнейших действий по отношению к этой транзакции.
</p><p>
 При откате транзакции выполняется системная процедура UNDO(), которая возвращает все старые значения в отмененной транзакции, последовательно проходя по протоколу, начиная с команды BEGIN TRANSACTION.
</p><p>
Для восстановления при сбое используется следующий механизм:
</p><p>
·        Если транзакция содержит команду начала транзакции, но не содержит команду фиксации с подтверждением ее выполнения, то выполняется последовательность действий как при откате транзакции, то есть восстанавливаются старые значения.
</p><p>
На самом деле восстановление происходит по более сложным алгоритмам, т.к.  изменения, как в журнал, так и в БД заносятся не сразу, а буферизуются. Журнализация изменений тесно связана не только с управлением транзакциями, но и с буферизацией страниц БД в оперативной памяти. Если бы запись об изменении БД, которая должна поступать в журнал при выполнении любой операции модификации БД, на самом деле немедленно записывалась во внешнюю память, это привело бы к существенному замедлению работы системы. Поэтому записи в журнале тоже буферизуются: при нормальной работе очередная страница выталкивается во внешнюю память  журнала только при полном заполнении записями.</p>
<h1>Блокировки</h1>
<p class="img-content"><img src="images/book1163.png" alt="Рис. 1.1" width="608" height="296"></p>
<p class="imgsign">Рис.6.3 Пример Управления Блокировки</p>

<p>В многопользовательских системах с одной базой данных одновременно могут работать несколько пользователей или прикладных программ. Одной из основных задач СУБД является обеспечение изолированности пользователей, то есть создание такого режима работы, чтобы каждому из пользователей казалось, что он работает с БД в одиночку. Такую задачу СУБД принято называть параллелизмом транзакций.
</p><p>
При параллельной обработке базы данных возникает три основных проблемы:
</p><p>
§  Пропавшие изменения. Эта ситуация возникает в тех случаях, когда 2 транзакции одновременно изменяют одну и ту   же запись в БД. Например, работают 2 оператора на приеме заказов, первый оператор принял заказ на 30 мониторов. Когда он обращался на склад, то там числилось 40 мониторов, и он, получив подтверждение от клиента, оформил продажу 30 мониторов из 40. Параллельно с ним работает второй оператор, который  принимает заказ на 20 таких же мониторов, и в свою очередь, обратившись на склад, он получает то же значение 40, и оформляет заказ для своего клиента. Заканчивая работу с данными, он выполняет команду Обновить, которая заносит 20 как остаток мониторов на складе. После этого первый оператор заканчивает работу со своим заказчиком и тоже выполняет команду Обновить, которая заносит остаток 10 как число мониторов, имеющихся на складе. В общей сложности они продали 50 мониторов при имеющихся  40, и при этом на складе будет числиться 10 мониторов.
</p><p>
§  Проблемы промежуточных данных. Связано с возможностью доступа к промежуточным данным. Допустим первый оператор, ведя переговоры со своим заказчиком, ввел заказанные 30 мониторов, но перед окончательным оформлением заказа клиент захотел выяснить еще некоторые характеристики товара. Приложение, с которым работает 1-й оператор, уже изменило остаток мониторов на складе, и там сейчас хранится информация о 10 оставшихся мониторах. В это время второй оператор пытается принять заказ от своего заказчика заказ на 20 мониторов, но его приложение показывает, что на складе осталось всего 10 мониторов и оператор вынужден отказать своему заказчику. В это время заказчик первого оператора принимает решение не покупать мониторы,  оператор делает откат транзакции и  на складе снова оказывается 40 мониторов. Такая ситуация стала возможной потому, что приложение второго оператора имело доступ к промежуточным данным, которые сформировало первое приложение.
</p><p>
§  Проблемы несогласованных данных. Связана с возможностью изменения данныx, уже прочитаныx другим приложением. Оба оператора начинают работать практически одновременно, получают начальное состояние склада 40 мониторов, а затем первый оператор продает своему заказчику 30 мониторов. Он завершает работу своего приложения, и оно выполняет команду фиксации транзакции COMMIT. Состояние БД непротиворечивое. В этот момент заказчик второго оператора решает сделать заказ и второй оператор, обращаясь   повторно к данным, видит, что количество мониторов изменилось. Второй оператор считает, что нарушена целостность транзакции, т.к. в течение выполнения одной работы он получил 2 различных состояния склада. Эта ситуация возникла потому, что приложение 1-го оператора смогло изменить кортеж с данными, который уже прочитало приложение второго оператора.
</p><p>
Обобщая перечисленные проблемы, можно выделить  следующие типы конфликтов между двумя параллельными транзакциями:
</p><p>
·        W-W – транзакция 2 пытается изменить объект, измененный не закончившейся транзакцией 1;
</p><p>
·        R-W – транзакция 2 пытается изменить объект, прочитанный не закончившейся транзакцией 1;
</p><p>
·        W-R транзакция 2 пытается читать объект, измененный не закончившейся транзакцией 1;</p>
<h2>Переопределение блокировок на уровне запроса. Типы блокировок</h2>

</p>Если после имени таблицы в предложении FROM следует одно из перечисленных ключевых слов, запрос вмешивается в работу диспетчера блокировок и применяется заданный тип блокировки:
</p><p>
·        NOLOCK- разрешает грязное чтение;
</p><p>
·        PAGLOCK- блокировка на уровне страниц;
</p><p>
·        ROWLOCK- блокировка на уровне записей;
</p><p>
·        TABLOCK-разделяемая блокировка таблицы;
</p><p>
·        TABLOCKX- монопольная блокировка таблицы
</p><p>
В настоящее время проблема блокировок является предметом большого числа исследований.
</p><p>
Различают два базовых типа блокировок (синхронизационных захватов):
</p><p>
Разделяемые (нежесткие) блокировки – это режим означает разделяемый захват объекта и используется для выполнения операции чтения объекта. Объекты, заблокированные таким образом, не изменяются в ходе выполнения транзакции и доступны другим транзакциям, но только в  режиме чтения;
</p><p>
Монопольные (жесткие) блокировки – не позволяют вообще никому, кроме владельца этой блокировки, обращаться к данным. Эти блокировки используются для команд, которые изменяют содержание или структуру таблицы и действуют до конца транзакции.
</p><p>
Захваты объектов несколькими транзакциями по чтению совместимы, то есть нескольким транзакциям допускается читать один и тот же объект. Захват объекта одной транзакцией по чтению не совместим с захватом другой транзакцией того же объекта по записи. Захваты одного объекта разными транзакциями по записи не совместимы.
</p><p>
Однако применение разных типов блокировок приводит к проблеме тупиков. Проблема тупиков возникла при рассмотрении выполнения параллельных процессов в операционных средах и также была связана с управлением разделяемыми (совместно используемыми) объектами. Пример тупика: Пусть транзакция А жестко блокирует таблицу 1, а затем  жестко блокирует таблицу 2. Транзакция В, наоборот жестко блокирует таблицу 2, а затем  жестко блокирует таблицу 1.

 </p><p>

Если обе эти транзакции начали работу одновременно, то после выполнения операций модификации первой таблицы они обе окажутся в бесконечном ожидании: транзакция А будет ждать завершения работы транзакции В и разблокировки таблицы 2, а транзакция В будет безрезультатно ждать завершения работы транзакции А и разблокировки таблицы 1.
</p><p>
Ситуации могут быть гораздо более сложными. Количество взаимно заблокированных транзакций может оказаться гораздо больше. Эту ситуацию каждая транзакция обнаружить самостоятельно не может. Ее должна разрешить СУБД. В большинстве коммерческих СУБД существует механизм обнаружения таких тупиковых ситуаций.
</p><p>
Основой обнаружения тупиковых ситуаций является построение (или постоянное поддержание) графа ожидания транзакций. Граф ожидания может представлять собой направленный граф, в вершинах которого расположены имена транзакций. Если транзакция Т1 ждет окончания транзакции Т2, то из вершины Т1 в вершину Т2 идет стрелка. Дополнительно стрелки могут быть помечены именами заблокированных  объектов и типом блокировки.
</p><p>
В механизме реализации блокировок используется понятие уровня изоляции блокировки, определяющее, сколько таблиц будет блокировано. Традиционно используется три уровня изоляции:
</p><p>
·        Уровень изоляции, называемый повторное чтение, реализует такую стратегию, что внутри данной транзакции все записи, извлеченные с помощью запросов, не могут быть изменены. Эти записи не могут быть изменены до тех пор, пока транзакция не завершиться.
</p><p>
·        Уровень изоляции, который называют указатель стабильности, предохраняет каждую запись от изменений на время, когда она считывается, или от чтения на время ее изменения.
</p><p>
·        Третий уровень стабильности, называется только чтение. Только чтение блокирует всю таблицу, а, следовательно, не может использоваться с командами модификации. Таким образом, только чтение гарантирует, что вывод запроса будет внутренне согласован с данными таблицы.
</p><p>
Итак, средство управления параллелизмом в СУБД определяет, то в какой степени, одновременно поданные команды будут мешать друг другу. В современных СУБД оно является адаптируемым средством, автоматически находящим оптимальное решение с учетом обеспечения максимальной производительности БД и доступности данных для действующих команд.<p>

<h1>Согласованность данных</h1>
<p>Консистентность данных— это согласованность данных друг с другом, целостность данных, а также внутренняя непротиворечивость. Множество всех условий, налагаемых на данные определяется моделью (структурой) данных.</p>
<h2>Точка- Согласованность во времени</h2>
<p>Согласованность на определенный момент времени - важное свойство файлов резервных копий и критическая цель программного обеспечения, которое создает резервные копии. Это также имеет отношение к конструкции систем дисковой памяти, особенно в отношении того, что происходит, когда они неожиданно отключаются.
</p><p>
В качестве соответствующего примера резервного копирования рассмотрим веб-сайт с базой данных, такой как онлайн-энциклопедия Википедия , который должен работать круглосуточно, но также должен регулярно создаваться резервные копии для защиты против катастрофы. Разделы Википедии постоянно обновляются каждую минуту, каждый день, в то время как база данных Википедии хранится на серверах в виде одного или нескольких очень больших файлов, для резервного копирования которых требуются минуты или часы.
</p><p>
Эти большие файлы, как и любая база данных, содержат множество структур данных, которые ссылаются друг на друга по местоположению. Например, некоторые структуры - это индексы , которые позволяют подсистеме базы данных быстро находить результаты поиска. Если структуры данных перестают правильно ссылаться друг на друга, то можно сказать, что база данных повреждена</p>
<h2>Согласованность в базах данных</h2>
<p>Понятие согласованности впервые появилось в области систем управления базами данных.</p><p>
Условия целостности данных (integrity constraints) стали записывать в виде правил и ввели триггеры — процедуры, которые вызывались до и после выполнения запроса. До запроса (триггер типа BEFORE) проходила проверка того, что данные имеют состояние, которое позволяет осуществить данный тип запроса. А после выполнения запроса (триггер типа AFTER) проверялось, что состояние базы данных удовлетворяет условим целостности. Если один из триггеров не срабатывал (возвращал НЕУСПЕХ или срабатывал с ошибкой), то транзакция откатывалась (отменялась).
</p><p>
Согласованность является важнейшим понятием теории управления данными (data management) и входит в четвёрку ACID (Atomicity, Consistency, Isolation, и Durability) — Атомарность, Консистентность, Замкнутость и Живучесть (стойкость).</p>

     </div>
     <nav role="navigation" aria-labelledby="book-label-2" class="book-navigation">
       <div class="page-links"><a href="book115.html" rel="prev" class="page-previous" title="Прошлая Тема">
         <i class="arrow icon-prev"><img src="images/arrowleft.png" alt=""></i>Тема 1.5</a>
         <a href="index.html" class="page-up" title="Содержание"><i class="arrow icon-up">
         <img src="images/arrowup.png" alt=""></i>Содержание</a>
         <a href="book117.html" rel="next" class="page-next" title="Следующая тема">Тема 1.7.
           <i class="arrow icon-next"><img src="images/arrowright.png" alt=""></i>
         </a>
       </div>
     </nav>
   </article>
 </div>
</div>
  </div>
</div>
<footer>
  <div class="footer">

  <div class="footer-inner">
    <div class="footer-ss">
     <div class="footer-name">
        <a href="https://nggtk.ru"> <p class="footer-name"><i class="arrow icon-up">
        <img src="images/icon1.png" alt=""></i>Сайт ГАПОУ НГТК</p> </a>
    <a href="https://vk.com/gapou_ngtk"> <p class="footer-name"><i class="arrow icon-up">
    <img src="images/icon2.png" alt=""></i>Группа ГАПОУ НГТК в ВК</p> </a>
     </div>

    </div>
    <div>
      <p>Создано Максяшкиным Валерием Валерьевичем <br>
      С помощью текстового редактора Atom</p>
    </div>
      <a href="#top"class="top">Back to top</a>
  </div>
</div>

</footer>

</body>

</html>
