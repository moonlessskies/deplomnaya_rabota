<!DOCTYPE html>
<html lang="ru">
<head>
  <title>Электронное учебное пособие Соадминистрирование баз данных и серверов</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="css/style.css">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>


  <header class="header">
    <div class="container">
      <div class="header__inner">
        <div class="header__logo">
         <img src="images/logotype-active.png" width="100px" alt="">
         <div class="name">
           <h2>Электронное учебное пособие</h2>
           <h2>Соадминистрирование баз данных и серверов</h2>
         </div>
         <a id="top"></a>
        </div>
        <nav class="nav">
          <a class="nav__link" href="index.html">Учебник</a>
          <a class="nav__link" href="basepr.html">Практика</a>
          <a class="nav__link" href="video1.html">Видеоматериал</a>
        </nav>
      </div>
    </div>
  </header>
<div class="layout">
  <aside class="aside-menu">
    <div class="block" id="block-htmlbook-block-28"><div class="block-content"></div></div>
    <div class="block" id="block-htmlbook-book-navigation">
       <h2 class="block-title">Содержание</h2>
     <div class="block-content">
  <ul class="menu">
                 <li class="leaf-collapsed">

                 <a class="not-active" href="index.html">Раздел 1. Технологии администрирования серверов и баз данных</a>
                    </li>
                    <li class="leaf-collapsed">

                 <a class="not-active">Тема 1.1. Принципы построения и администрирования баз данных
                        </a>
                       </li>
                         <div class="sub-menu">
                           <li class="leaf-collapsed">
                        <a class="not-active" href="book111.html">1.Обязанности администратора баз данных. Основные утилиты администратора баз данных. Режимы запуска и останова базы данных.</a>
                              </li>

     	      <li class="leaf-collapsed">

         <a class="not-active" href="book112.html">2.Пользователи базы данных. Привилегии, назначение привилегий. Управление пользователями баз данных</a>
               </li>
               <li class="leaf-collapsed">

         <a class="not-active" href="book113.html">3.Табличные пространства и файлы данных. Модели и типы данных.</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book114.html">4.Схемы и объекты схемы данных. Блоки данных, экстенты сегменты.</a>
               </li>
               <li class="leaf_active-trail">
        <a href="book115.html" class="is-active">5.Структуры памяти. Однопроцессорные и многопроцессорные базы данных
               <span class="pointer" style="border-width: 11px 6px;"></span></a>
              </li>

     	      <li class="leaf-collapsed">

         <a class="not-active" href="book116.html">6.Транзакции, блокировки и согласованность данных</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book117.html">7.Журнал базы данных: структура и назначение файлов журнала, управление переключениями и контрольными точками</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book118.html">8. Словарь данных: назначение, структура, префиксы </a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book119.html">9. Правила Дейта</a>
               </li>
             </div>

     	      <li class="leaf-collapsed">

         <a class="not-active">Тема 1.2. Серверы баз данных</a>
               </li>

               <div class="sub-menu">

     	      <li class="leaf-collapsed">


         <a class="not-active" href="book121.html">1.Понятие сервера. Классификация серверов. Принципы разделения между клиентскими и серверными частями. Типовое разделение функций</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book122.html">2.Протоколы удаленного вызова процедур. Требования к аппаратным возможностям и базовому программному обеспечению клиентов и серверов</a>
               </li>
     	      <li class="leaf-collapsed">
         <a class="not-active" href="book123.html">3.Хранимые процедуры и триггеры</a>
               </li>
     	      <li class="leaf-collapsed">

         <a class="not-active" href="book124.html">4.Характеристики серверов баз данных. Механизмы доступа к базам данных</a>
               </li>
               <li class="leaf-collapsed">
              <a class="not-active" href="book125.html">5. Аппаратное обеспечение. Для квалификации «Администратор баз данных»: Развертывание серверов баз данных</a>
                  </li>
                  <li class="leaf-collapsed">
                 <a class="not-active" href="book126.html">6. Банк данных: состав, схема</a>
                     </li>
             </div>
             <li class="leaf-collapsed">
          <a class="not-active">Тема 1.3.Администрирование баз данных и серверов</a>
                </li>
     <div class="sub-menu">
      <li class="leaf-collapsed">
      <a class="not-active" href="book131.html">1.Технология установки и настройка сервера MySQL в операционной системе Windows.Клиентские настhойки, протоколирование, безопасность</a>
         </li>
         <li class="leaf-collapsed">
      <a class="not-active" href="book132.html">2.Технология установки и настройка сервера MySQL в операционных системах Linux</a>
            </li>
            <li class="leaf-collapsed">
         <a class="not-active" href="book133.html">3.Удаленное администрирование</a>
               </li>
               <li class="leaf-collapsed">
            <a class="not-active" href="book134.html">4.Аудит базы данных. Аудиторский журнал. Установка опций, включение и отключение аудита. Очистка и уменьшение размеров журнала</a>
                  </li>
                  <li class="leaf-collapsed">
               <a class="not-active" href="book135.html">5.Технологии создания базы данных с применением языка SQL.Добавление, удаление данных и таблиц</a>
                     </li>
                     <li class="leaf-collapsed">
                  <a class="not-active" href="book136.html">6.Создание запросов, процедур и триггеров. Для квалификации «Администратор баз данных». Создание запросов и процедур на изменение структуры базы данных</a>
                        </li>
                        <li class="leaf-collapsed">
                     <a class="not-active" href="book137.html">7.Динамический SQL и его операторы.</a>
                           </li>
                           <li class="leaf-collapsed">
                        <a class="not-active" href="book138.html">8.Особенности обработки данных в объектно-ориентированных базах данных</a>
                              </li>
                              <li class="leaf-collapsed">
                           <a class="not-active" href="book139.html">9. Инструменты мониторинга нагрузки сервера</a>
                                 </li>

    </div>
    <li class="leaf-collapsed">
    <a class="not-active" href="index.html">Раздел 2. Обеспечение качества и сертификация информационных систем </a>
       </li>
       <li class="leaf-collapsed">
     <a class="not-active">Тема 2.1. Защитаи сохранность информации баз данных</a>
          </li>
     <div class="sub-menu">
          <li class="leaf-collapsed">
        <a class="not-active" href="book211.html">1.Законодательство Российской Федерации в области защиты информации. Требования безопасности к серверам баз данных. Классы защиты</a>
             </li>
             <li class="leaf-collapsed">
           <a class="not-active" href="book212.html">2.Основные группы методов противодействия угрозам безопасности в корпоративных сетях</a>
                </li>
                <li class="leaf-collapsed">
             <a class="not-active" href="book213.html">3.Программно-аппаратные методы защиты процесса обработки и передачи информации. Политика безопасности, настройка политики безопасности</a>
                   </li>
                   <li class="leaf-collapsed">
                <a class="not-active" href="book214.html">4.Виды неисправностей систем хранения данных</a>
                      </li>
                      <li class="leaf-collapsed">
                   <a class="not-active" href="book215.html">5.Резервное копирование: цели, методы, концепции, планирование, роль журнала транзакций. Виды резервных копий</a>
                         </li>
                         <li class="leaf-collapsed">
                      <a class="not-active" href="book216.html">6.Утилиты резервного копирования </a>
                            </li>
                            <li class="leaf-collapsed">
                         <a class="not-active" href="book217.html">7.Восстановление базы данных: основные алгоритмы и этапы</a>
                               </li>
                               <li class="leaf-collapsed">
                            <a class="not-active" href="book218.html">8.Восстановление носителей. Воссоздание утраченных файлов. Полное восстановление. Неполное восстановление</a>
                                  </li>
                                  <li class="leaf-collapsed">
                               <a class="not-active" href="book219.html">9.Мониторинг активности и блокирование</a>
                                     </li>
                                     <li class="leaf-collapsed">
                                  <a class="not-active" href="book2110.html">10.Автоматизированные средства аудита</a>
                                        </li>
                                        <li class="leaf-collapsed">
                                     <a class="not-active" href="book2111.html">11.Брандмауэры</a>
                                           </li>
                                  </div>
     <li class="leaf-collapsed">
      <a class="not-active">Тема 2.2 Сертификация информационных систем</a>
        </li>
        <div class="sub-menu">
        <li class="leaf-collapsed">
         <a class="not-active" href="book221.html">1.Уровни качества программной продукции</a>
           </li>
           <li class="leaf-collapsed">
            <a class="not-active" href="book222.html">2.Требования к конфигурации серверного оборудования и локальных сетей.Оформление требований.</a>
              </li>
              <li class="leaf-collapsed">
               <a class="not-active" href="book223.html">3.Объекты информатизации, требующие обязательной сертификации программных средств и обеспечения</a>
                 </li>
                 <li class="leaf-collapsed">
                  <a class="not-active" href="book224.html">4.Сертификаты безопасности: виды, функции, срок действия. Проверка наличия сертификата безопасности</a>
                    </li>
                    <li class="leaf-collapsed">
                     <a class="not-active" href="book225.html">5. Системы сертификации. Процедура сертификации.</a>
                       </li>
                       <li class="leaf-collapsed">
                        <a class="not-active" href="book226.html">6. Платформы и центры сертификации. Сертификат разработчика. Процесс подписи и проверки кода</a>
                          </li>
                          <li class="leaf-collapsed">
                           <a class="not-active" href="book227.html">7. SSL сертификат: содержание, формирование запроса, проверка данных с помощью сервисов</a>
                             </li>
                             <li class="leaf-collapsed">
                              <a class="not-active" href="spicok.html">Список источников</a>
                                </li>
                              </div>
                                                       </ul>



     </div>
    </div>
 </aside>

 <div id="content" class="three-col">
   <div class="block" id="block-content">
     <div class="block-content">
       <article role="article">
         <h1 class="h1-content"><span>5.Структуры памяти. Однопроцессорные и многопроцессорные базы данных</span></h1>
         <nav role="navigation" aria-labelledby="book-label-2" class="book-navigation">
           <div class="page-links"><a href="book114.html" rel="prev" class="page-previous" title="Прошлая Тема">
             <i class="arrow icon-prev"><img src="images/arrowleft.png" alt=""></i>Тема 1.4.</a>
             <a href="index.html" class="page-up" title="Содержание"><i class="arrow icon-up">
             <img src="images/arrowup.png" alt=""></i>Содержание</a>
             <a href="book116.html" rel="next" class="page-next" title="Следующая тема">Тема 1.6.
               <i class="arrow icon-next"><img src="images/arrowright.png" alt=""></i>
             </a>
           </div>
         </nav>
           <div><h2>Структуры памяти экземпляра БД</h2>
<p>Экземпляр БД Oracle состоит из блоков разделяемой памяти, называемых system global area (SGA) и background процессов. SGA содержит три обязательные структуры данных:</p>
<ul>
  <li>
    Thedatabasebuffercache / содержит копии блоков данных считанные из файлов данных</li><li>
    Thelogbuffer / содержит данные о транзакциях которые ещё не записаны в redolog/li>/li></li><li>
    Thesharedpool / содержит проверенные SQL выражения и кэш словаря данных, содержащий таблицы, представления и триггеры/li>
  </li>
</ul>
<p>Также дополнительно могут быть:</p>

<ul>
  <li>Largepool</li><li>
Javapool</li><li>
Streemspool
  </li>
</ul>

<p>Эти структруры показаны на рисунке 1-5 и мы обсудим обязательные структуры.
</p><p>
Пользовательские сессии тоже требуют памитя на сервере. Как мы помним это неразделяемая область памяти, которая называется PGA. У каждой сессии своя PGA.
</p><p>
Управление объёмом памяти может осуществляться автоматически, или управляться администратором базы данных. Рекомендуется использовать автоматический способ управления.</p>
<p class="img-content"><img src="images/book1151.png" alt="Рис. 1.1" width="608" height="296"></p>
<p class="imgsign">Рис.5.1 Ключевые структуры памяти System Global Area</p>

<h2>Database buffer cache</h2>

<p>Database buffer cache – это область где выполняются SQL команды. Когда мы обновляем данные, они не изменяются непосредственно в файлах данных на жёстком диске. Блоки данных, которые содержат данные с которыми мы работает вначале копируются в buffer cache (если они ещё не находятся там). Изменения (вставка, измнение или удаление данных) применяются к этим копиям данных в буфферном кэше. Затем эти блоки данных остаются в памяти некоторое время, пока место которое они занимают не понадобится для работы над какими-либо другими данными.
</p><p>
Когда мы хотим посмотреть какие-то данные – операция выдачи информации тоже происходит через кэш. Вначале находятся блоки данных которые мы запросили и копируются в буфер кэш (опять же если их ещё там нет); затем нужные данные переносятся в PGA для дальнейшей обработки.
</p><p>
Термин блок. Файлы данных представляют из себя данные сгруппированые в блоки фиксированной длины. Данные в таблицах (строки) и другие объекты такие как индексы и т.п. хранятся в этих блоках. Buffer cache также сгруппирован в структуры в памяти, чтобы вмещать в себя ровно один блок. Строки же могут быть разной длины: длина строки зависит от количества столбцов в ней, не важно есть ли в этих столбцах данные или нет. В зависимости от размера блока (размер выбирается администратором базы данных) и размера строки может быть несколько строк в блоке, или строка занимать несколько блоков. Структуру блока мы более детально рассмотрим в теме организация данных.
</p><p>
В идеале – блоки данных содержащие наиболее часто используемые данные будут в buffer cache, таким образом снижая количество операций чтения/записи. Как типичный пример работы буфер кэша рассмотрим пример типичной операции продавца в магазине, который получает данные о клиенте и обновляет их. Будут использованы примерно такие запросы:
</p><p>

</p><p>
SELECT CUSTOMER_ID,CUSTOMER_NAME FROM CUSTOMERS;
</p><p>
UPDATE CUSTOMERS SET CUSTOMER_NAME=’Вася’ WHERE CUSTOMER_ID=100;
</p><p>
COMMIT;
</p><p>


Для того чтобы выполнить SQL команду селект пришедшую от пользователя, серверный процесс этой сессии вначале посмотрим есть ли уже в буфере блок данных, который содержит необходимую информацию. Если эта информация найдена, данные будут прочитаны (hit) из буфера. Преположим что данные не в буфере (miss), тогда серверный процесс считает блоки из файлов данных и поместит их в буфер, перед тем как вернуть данные пользователю.
</p><p>
Потом пользователь запускает команды UPDATE и COMMIT, которые будут обработаны серверным процессом. Допуская, что данные всё ещё доступны в buffer cache на момент выполнения этого запроса, строка будет обновлена в буфер кэше. В данном примере мы получим эффективность использования буфера – 50%. 2 раза доступ к данным в кэше буфера, один раз чтение данных с диска. Формула расчёта: 1-«кол-во чтений с диска»/кол-во чтений с буфера»). В хорошо оптимизированных базах данных этот показатель может достигать 90%.
</p><p>
Буффер в котором данные в блоках отличаеются от данных этих блоков на дисковом пространстве – называбтся грязными (dirty buffers). Буфер будет чистым (clean) когда блок только скопирован с диска в память: в этот момент времени данные одинаковые и в памяти и на диске. В итоге, грязные блоки данных должны быть записан назад на диск и тогда буфер опять станет чистым. Но даже после записи на диск, блоки остаются в памяти, пока их не перепишут другими блоками.
</p><p>
Важно, что нету прямой зависмости количества обновлений данных в буфере (комманд COMMIT) и количества операция записи данных назад в файлы данных. Запись в файлы данных производится background process-ом – database writer.
</p><p>
Размер buffer cache очень важен для производительности. Значение должно быть адекватно рассчитано, не минимальное — чтобы все часто используемые блоки (неважно чистые или грязные) находились в буфере, но не настолько большое чтобы даже редко используемые данные тоже находились в буфере. Недостаточный объём приведёт к избыточному использованию чтения/записи с диска, так как блоки будут читаться с диска, тут же переписываться и снова читаться. Слишком большой объём не настолько плохо как слишкомй маленький (пока он меньше чем размер реальной доступной оперативной памяти) но тоже может вызывать определённые проблемы: например запуск базы данных будет дольше, так как требуется форматирование большого объёма памяти.
</p><p>
Память для buffer cache выделяется на этапе запуска экземпляра БД. До версии 9i нельзя изменить размер буфер кэша без перезапуска инстанса. Начиная с версии 10 g – размер буфера кэша можно изменять как автоматически (включить механизм автоматическго управления), так и вручную.</p>

<h2>Буфер логов (log buffer)</h2>
<p class="img-content"><img src="images/book1152.png" alt="Рис. 1.1" width="608" height="296"></p>
<p class="imgsign">Рис.5.2 Буфер логов (log buffer)</p>

<p>Буфер логов – это небольшая, краткосрочная выделенная область памяти для хранения записей изменений (change vector) до записи их в журнал (redo log) на диске. Запись изменений – это изменение произошедшее с чем либо; выполнений DML команда создаёт записи изменений. Сохранение всех таких записей – это гарантия того, что данные никогда не будут утеряны. Когда бы не изменились данные в блоке – запись изменений в блоке должна быть записана  в журнал. Впоследствии эти записи могут быть считаны и применены к резервной копии файлов данных, если возникла необходимость.
</p><p>
Изменения не пишутся в журнал серверными процессами сессий. Если бы это было реализовано таким образом, сессиям пришлось бы ждать выполнения операций чтения/записи чтобы закончить выполнения любой DML команды. Вместо этого сессии пишут в буфер логов в памяти. Это гораздо быстрее чем писать на диск. Уже из буфера логов записи изменений (сформированные из разных сессий) пишутся в журнал.Одна операция записи в журнал может влючать множество изменений. Эти изменения пишутся примерно в реальном времени – но как только какая-нибудь сессия исполняет команду COMMIT – тут же происходит запись в журнал. Запись осуществляется background процессом – log writer-ом (LGWR).
</p><p>
Буфер логов небольшая (по сравнению с другими) область памяти, потому что время жизни данных там очень короткое. Изменения записываются в этот буфер и почти в тот же момент времени пишутся на диск. Нет необходимости делать размер больше чем несколько мегабайт, и более того, использование значение сильно большего чем значение по умолчанию может плохо сказаться на производительности. Значение по умолчанию устанавливается сервером Oracle в зависимости от количества процессоров на серверах.
</p><p>
Невозможно задать значение, меньше чем значение по умолчанию. Если попробовать сделать это, Oracle просто установит значение по умолчанию. Можно установить большее значение, но обычно этого делать не стоит. Основаная проблема в том, что когда выполняется команда COMMIT, запускается запись изменений из буфера на диск, и пока операции записи осуществляется, сессия которая запустила команду COMMIT будет ждать. Запись изменений важная часть архитектуры Oracle. Идея того что подтверждённые изменения никогда не будут утеряны в том, что выполнение команды commit считается успешным только  тогда, когда данные изменены в buffer cache и записи зименений (vector change) записаны в журнал на диске (это значит что изменения могуть быть повторены при необходимости). Большой буфер логов может привести к тому что операция записи из него на диск будет занимать длительное время, а в это время сессия не может продолжать работу.
</p><p>
Память для буфера логов выделяется в момент запуска экземпляра БД и размер не может быть изменен без перезапуска. Это круговой буффер. Серверные процессы пишут записи изменений, и текущий указатель перемещается. Log writer записывает эти изменения на диск группами, и когда он это делает, место занятое этими записями становится снова доступным и может быть переписано новыми записями. В момент самой высокой нагрузки на сервер, может случиться так, что новые векторы должны быть записаны быстрее чем log writer может записать их на диск. Если такое случается все команды манипулированяи данными будут «подвисать» на некоторое время, пока log writer не очистит буфер.
</p><p>
Процесс записи изменений из буфера на диск одно из самых главных узких мест в архитектуре Oracle. Команды изменения не могут выполняться быстрее чем запись log writer-ом из буфера на диск.</p>
<h2>The shared pool</h2>
<p>Shared pool самая сложная область в SGA. Она состоит из под-областей, которые управляются Oracle сервером. Мы обсудим только 4 кмпонента:
</p><p>
Library cache
</p><p>
Data dictionary cache
</p><p>
PL/SQL area
</p><p>
SQL PL/SQL function result cache
</p><p>
Управление этими структурами происходит автоматически. Размер изменяется динамически в зависимости от писпользования, но не превышает размер всей области памяти. Shared pool может тоже изменять размер или посредством настройки автоматического управления или командами администратора базы данных.

</p>
<h2>Library cache</h2>
<p>Library cache это область памяти где хранятся последние выполненные запросы в разобранном виде. Разбор (parsing) – это процесс преобразования инструкция написанный программистом в исполняемые команды понятные Oracle. Этот процесс Oracle запускает по требованию. Хранение разобранных команд очень сильно увеличивает производительность, потому что процесс разбора занимает время. Рассмотрим пример простого запроса:
</p><p>
SELECT * FROM PRODUCTS WHERE PRODUCT_ID=100;
</p><p>
Перед тем как выполнять запрос, надо узнать что написано в запросе и как его выполнять. Начиная с того, что такое PRODUCTS? Мжет быть это таблица? Или синоним, представление? Вообще существует ли такой объект? Дальше символ «звездочка» — какие столбцы в таблице PRODUCTS (если это действительно таблица)? Есть ли у пользователя необходимые права чтобы просматривать эту таблицу? Вопросы на эти ответы и многие другие надо найти в словаре данных. Важное замечание – алгоритм поиска разобранного запроса в кэше базируется на ASCII символах которые использованы в запросе. Небольшое различие (к примеру использование строчных символов вместо прописных) может привести к тому что запрос будет разбираться опять.
</p><p>
После разбора запроса, сервер должен решить как наиболее оптимально выполнять его. Есть ли индекс для поля PRODUCT_ID? Если он есть, будет ли быстрее использовать индекс чтобы найти нужную строку, или проще просмотреть всю таблицу? И ещё больше и больше запросов в словарь данных. Бывает что для простого запроса надо создать много запросов в словарь данных и разбор занимает больше времени чем выполнение самого запроса. Смысл library cache – хранить запросы в разобранном виде, готовые к выполнению. Первый вызов необходимо обработать – второй вызов такого же запроса, тут же готов к выполнению. В хороших приложениях запросы подготавливаются один раз – а выполняются миллионы раз. Это позволяет сэкономить огромное количество времени.</p>
<h2>Кэш словаря данных (Data dictionary cache)</h2>
<p>Data dictionary cache иногда называют row cache. В нём хранятся определения использованных объектов: описания таблиц, индексов, пользователей и другие мета-данные. Хранения этих данные в кэше в памяти SGA, где они доступны для всех сессий, в отличии от чтения их со словаря данных с диска, сильно увеличивает производительность разбора команд.
</p><p>
Кэш словаря данных хранит информацию об объектах, и когда нужно разобрать запрос это можно сделать без чтения данных из словаря данных. Предположим что выполняются 2 запроса
</p><p>


SELECT SUM(ORDER_AMOUNT) FROM ORDERS;
</p><p>
SELECT * FROM ORDERS WHERE ORDER_NO=100;

 </p><p>

Два запроса нужно разобрать, поскольку они разные, но разбор первого запроса загрузит информацию о таблице ORDERS в кэш, и разбор второга запроса будет быстрее, потому что уже не нужно считывать информацию.</p>
</p><p>
<h2>Область PL/SQL (PL/SQL Area)</h2>
<p>Объектами PL/SQL являются процедуры, функции, пакеты, сложные типы, триггеры. Все они хранятся в словаре данных в виде исходного когда и скомпилированной программы. Когда PL/SQL объект вызывается сессией, необходимо прочитать нужную информацию из словаря данных. Для того чтобы исключить повторное чтение, эти объекты кэшируются в области PL/SQL в shared pool.
</p><p>
Первый вызод займёт некоторое время, так как нужно считать информацию, но следующие вызовы будут гораздо быстрыее так как объект уже будет в области PL/SQL.</p>
<h2>SQL Query and PL/SQL Function Result Cache</h2>
<p>Данный кэш появился в версии 11 g. Во многих приложениях, одинаковые запросы выполняются много раз,  или одной сессией или разными. Создание этого кэша позволило Oracle серверу хранит результаты подобных запросов в памяти. Когда запрос будет выполняться повторно вместо его реального выполнения, результат возьмётся из кэша.
</p><p>
Механизм кэширования отслеживает изменились ли данные в таблицах, которые используются в такого рода запросах. Если данные изменились, запрос будет перевыполнен. Это позволяет устранить проблему выдачи некорретных данных.
</p><p>
PL/SQL функции работают примерно также. Когда функция выполняется – результат кэшируется. Если параметры или данные в таблицах используемых в функции изменились, функция будет перезапущена – иначе будет использоваться кэшированный результат.
</p><p>
По умолчанию, SQL Query PL/SQL function result cache отключен. Но если его включить – можно получить очень существенное ускорение производительности. Для данного вида кэша администратор может установить максимальный размер памяти.</p>
<h2>Управление размером shared pool</h2>
<p>Выбор оптимального объёма shared pool-а очень важен для производительности. Он должен быть достаточно большой для хранения всех часто используемых запросов и объектов, но не настолько большой чтобы хранить кэши для всех запросов и объектов. Слишком маленький размер снижает производительность так как сессиям нужно выделять память и записывать данные для запросов, потом другой запрос может переписать эту информацию и придётся повторять операцию опять. Слишком большой размер плохо влияет на производительность так как увеличивается время поиска в кэше.
</p><p>
Память в shared pool выделятся согласно алгоритму LRU (least recently used). Когда нужно выделить место в shared pool, сервер будет искать объекты которые не использовались дольше всех. Если этот объект потом понадобится опять – его придется перезагрузить (возможно снова удалив другой объект).
</p><p>
Shared pool выделяет память в момент запуска экземпляра БД. Начиная с версии 9i размер может изменяться динамически без перезапуска, либо механизмом атовматического управления, либо администратором.</p>
<h1>Однопроцессорные и многопроцессорные компьютеры</h1>
<h2>Однопроцессорные ЭВМ</h2>
<p>С появлением в США микропроцессоров (1971 г.) начал развиваться новый класс вычислительных машин — микроЭВМ. За короткое время микропроцессоры прошли большой путь развития: от первого поколения 4- и 8-разрядных микропроцессоров, выполненных по р-канальной МОП-технологии, до четвертого поколения 32- и 64-разрядных микропроцессоров.
</p><p>
В настоящее время реализуется программа по разработке в ближайшие 8—10 лет новых типов компьютеров1:</p>
<ul>
  <li>
    • многопроцессорных компьютеров с высокой степенью параллелизма обработки информации;
    </li><li>
    • компьютеров с нейронными сетями;
    </li><li>
    • компьютеров, в которых для передачи информации используется свет.
  </li>
</ul>

<p>
Появление персональных компьютеров — наиболее яркое событие в области вычислительной техники, это динамично развивающийся сектор отрасли. С внедрением компьютеров решение задач информатизации общества поставлено на реальную основу. Кроме того, потребовался новый подход к организации систем обработки данных, к созданию новых информационных технологий. Возникла необходимость перехода от систем централизованной обработки данных к системам распределенной обработки данных, т.е. к компьютерным (вычислительным) сетям различных уровней — от локальных до глобальных
</p><p>
Ранее, при рассмотрении обобщенной структуры ЭВМ, отмечалось, что основным устройством, непосредственно осуществляющим переработку поступающей в ЭВМ информации, является процессор. Основные принципы построения процессоров, в общем-то, одинаковые, причем наиболее наглядно их можно продемонстрировать на примере простейшего микропроцессора.
</p>
<h2>Многопроцессорные ЭВМ</h2>
<p>Назначение, область применения и способы оценки производительности многопроцессорных вычислительных систем
</p><p>
В </p><p> время сфера применения многопроцессорных вычислительных систем (МВС) непрерывно расширяется, охватывая все новые области в самых различных отраслях науки, бизнеса и производства. Стремительное развитие кластерных систем создает условия для использования многопроцессорной вычислительной техники в реальном секторе экономики.
</p><p>
Если традиционно МВС применялись в основном в научной сфере для решения вычислительных задач, требующих мощных вычислительных ресурсов, то сейчас, из-за бурного развития бизнеса резко возросло количество компаний, отводящих использованию компьютерных технологий и электронного документооборота главную роль. В связи с этим непрерывно растет потребность в построении централизованных вычислительных систем для критически важных приложений, связанных с обработкой транзакций, управлением базами данных и обслуживанием телекоммуникаций. Можно выделить две основные сферы применения описываемых систем: обработка транзакций в режиме реального времени (OLTP, on-line transaction processing) и создание хранилищ данных для организации систем поддержки принятия решений (Data Mining, Data Warehousing, Decision Support System).
</p><p>
^ Матричные структуры из очень большого числа простых процессоров.
</p><p>
В 80е г. г. были построены 3 очень большие двумерные системы. В их число входят7:
</p><p>
-распределенный матричный процессор DAP(distributed array processor) размером 64Х64, спроектированный фирмой ICL.
</p><p>
-сотовый логический процессор изображений CLIP-4(cellular logic image processor) размером96Х96, разработанный в лондонском университетском колледже,
</p><p>
-большой параллельный процессор MPP(massively parallel processor) размером 128Х128, спроектированный фирмами GoodYear-Aerospace и NASA Goddard.
</p><p>
В этих системах каждый из тысяч процессоров выполняет одну и ту же команду над различными потоками данных. Данные, которые необходимо обработать, и объем которых в идеале соответствует размерам матрицы процессоров, вводятся в систему таким образом, что каждый из процессоров имеет в собственной памяти одно подмножество таких данных, например, один элемент растра.
</p><p>
Затем каждый из процессоров обрабатывает данные, хранящиеся в собственной памяти, а также данные его ближайших соседей.
</p>
<p>Архитектура МП-системы8:</p>
<ul>
  <li>ЦП
</li><li>
Шины коммуникаций контроллера прерываний
</li><li>
Контроллер прерываний APIC
</li><li>
Модуль общей памяти
</li><li>
Контроллер шины памяти
</li><li>
Буфер графических фреймов
</li><li>
Контроллеры кэша
</li><li>
Контроллер прерываний APIC
</li><li>
Кэш-память
</li><li>
Интерфейс ввода-вывода
</li><li>
Высокопроизводительная шина
</li><li>
Шина расширения ввода-вывода памяти
</li><li>
Основные компоненты

  </li>
</ul>
<p>МП-спецификация определяет системную архитектуру на основе следующих компонентов аппаратуры: системные процессоры, контроллеры APIC, системная память, шина расширения ввода-вывода.</p>



<p>Когда несколько приложений запрашивают обработку своих заданий на однопроцессорном компьютере, весь объем работы приходится выполнять его единственному процессору. Целью параллельной обработки обычно является повышение производительности приложений. Когда приложение выдает запрос на выполнение задания для многопроцессорного компьютера, компьютер разбивает это задание на логические подзадачи, а затем обрабатывает их с помощью нескольких процессоров параллельно, что уменьшает время выполнения задания.
</p><p>
Число подзадач, получаемых в результате разбиения одного большого задания, называется степенью параллельности (degree of parallelism).Уменьшение времени обработки информации, необходимого для выполнения задачи, прямо пропорционально степени параллельности. Быстродействие систем с параллельной обработкой стараются повышать так, чтобы обеспечить максимальную производительность каждого процессора системы.</p>

     </div>
     <nav role="navigation" aria-labelledby="book-label-2" class="book-navigation">
       <div class="page-links"><a href="book114.html" rel="prev" class="page-previous" title="Прошлая Тема">
         <i class="arrow icon-prev"><img src="images/arrowleft.png" alt=""></i>Тема 1.4.</a>
         <a href="index.html" class="page-up" title="Содержание"><i class="arrow icon-up">
         <img src="images/arrowup.png" alt=""></i>Содержание</a>
         <a href="book116.html" rel="next" class="page-next" title="Следующая тема">Тема 1.6.
           <i class="arrow icon-next"><img src="images/arrowright.png" alt=""></i>
         </a>
       </div>
     </nav>
   </article>
 </div>
</div>
  </div>
</div>
<footer>
  <div class="footer">

  <div class="footer-inner">
    <div class="footer-ss">
     <div class="footer-name">
        <a href="https://nggtk.ru"> <p class="footer-name"><i class="arrow icon-up">
        <img src="images/icon1.png" alt=""></i>Сайт ГАПОУ НГТК</p> </a>
    <a href="https://vk.com/gapou_ngtk"> <p class="footer-name"><i class="arrow icon-up">
    <img src="images/icon2.png" alt=""></i>Группа ГАПОУ НГТК в ВК</p> </a>
     </div>

    </div>
    <div>
      <p>Создано Максяшкиным Валерием Валерьевичем <br>
      С помощью текстового редактора Atom</p>
    </div>
      <a href="#top"class="top">Back to top</a>
  </div>
</div>
</footer>

</body>

</html>
